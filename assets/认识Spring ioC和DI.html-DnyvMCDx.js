import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as t,o as n}from"./app-VxsXiEfJ.js";const e={};function l(p,i){return n(),a("div",null,[...i[0]||(i[0]=[t(`<h2 id="spring-ioc" tabindex="-1"><a class="header-anchor" href="#spring-ioc"><span>Spring IoC</span></a></h2><p><strong>Spring IoC</strong>（（Inversion of Control）控制反转）​是 Spring 框架的核心机制（理解为设计模式），用于​<strong>​解耦组件依赖关系​</strong>​，将对象的创建、依赖管理和生命周期交<strong>由 Spring 容器统一控制</strong></p><p>可以理解为<strong>类与类之间的依赖通过容器来控制、配置实现</strong>；</p><p>传统编程中，对象自己创建依赖的其他对象（比如A类里直接new B类）。如果代码中直接写<code>A a = new A();</code>，然后<code>a.setB(new B());</code>，会导致A和B强绑定。修改B的代码时，必须同步修改A的代码，维护成本极高。</p><p>而在Spring IOC中，对象的创建和依赖关系由Spring容器统一管理，通过配置文件或注解（如<code>@Autowired</code>）自动完成注入。</p><p>例:<br> 想写一个类，UserServicelmpl，写该类时要创建 UserDaolmpl对象，传统方法是</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">UserDaol</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> userDao </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> UserDaolmpl</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用spring框架管理的话：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">UserDaol</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> userDao </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> spring客户端</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getBean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(id标识)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的id标识表示UserDaolmpl（在配置文件中告诉spring客户端，id标识=UserDaolmpl）</p><h2 id="di" tabindex="-1"><a class="header-anchor" href="#di"><span>DI</span></a></h2><p>​<strong>​DI（Dependency Injection，依赖注入）​</strong>​ 是一种通过外部传递对象依赖关系，而非在代码内部直接创建依赖对象的技术。它是实现 ​<strong>​控制反转（IoC）​</strong>​ 的核心<strong>手段</strong>之一，目的是降低代码耦合度，提高灵活性和可维护性。</p><table><thead><tr><th>​<strong>​场景​</strong>​</th><th>​<strong>​正确方法（DI）​</strong>​</th><th>​<strong>​错误方法（硬编码依赖）​</strong>​</th></tr></thead><tbody><tr><td>用户注册功能</td><td><code>UserService</code>通过<code>@Autowired</code>注入<code>UserDao</code></td><td><code>UserService</code>内部直接<code>new UserDao()</code></td></tr><tr><td>数据库切换（如MySQL→Redis）</td><td>只需修改容器配置，注入新的<code>RedisDao</code></td><td>需逐行修改所有<code>new UserDao()</code>代码</td></tr><tr><td>看不懂没关系，后续的学习中将慢慢了解</td><td></td><td></td></tr></tbody></table><h2 id="spring-ioc-容器" tabindex="-1"><a class="header-anchor" href="#spring-ioc-容器"><span>spring ioc 容器</span></a></h2><p>普通容器：只能用于存放。<br> 复杂容器：不只用于存储对象，还能用于管理存储的对象的生命周期</p><p>我们即将要学习的 SpringIoC 容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。</p><p>Spring IoC 容器管理的java对象成为spring bean</p><p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以 XML、Java 注解或 Java 代码形式表现。</p><h2 id="容器接口" tabindex="-1"><a class="header-anchor" href="#容器接口"><span>容器接口</span></a></h2><p>本小节内容了解即可</p><p>Spring 提供了两种 IOC 容器接口：</p><ol><li>​<strong>​<code>BeanFactory</code>​</strong>​（基础容器）： <ul><li>最小化功能，仅支持 Bean 的加载和依赖注入。</li><li>示例：<code>DefaultListableBeanFactory</code>。</li></ul></li><li>​<strong>​<code>ApplicationContext</code>​</strong>​（增强容器）： <ul><li>继承自 <code>BeanFactory</code>，提供高级功能（如 AOP、事件传播、国际化等）。</li><li>常用实现类：<code>ClassPathXmlApplicationContext</code>（XML 配置）、<code>AnnotationConfigApplicationContext</code>（注解配置）。</li></ul></li></ol><p><strong>ApplicationContext容器的实现类</strong>：</p><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象。比如当配置文件在当前项目之外时</td></tr><tr><td>AnnotationConfigApplicationContext</td><td>通过读取Java配置类创建 IOC 容器对象</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr><tr><td>下面为<code>ClassPathXmlApplicationContext</code>容器的创建</td><td></td></tr></tbody></table><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">package</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> com.example.demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> com.example.dao.UserDao</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.springframework.context.ApplicationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.springframework.context.support.ClassPathXmlApplicationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserDaoDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {  </span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        ApplicationContext</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> app</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ClassPathXmlApplicationContext</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;applicationContext.xml&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="spring-di" tabindex="-1"><a class="header-anchor" href="#spring-di"><span>Spring DI</span></a></h2><p><strong>DI (Dependency Injection) 依赖注入</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 传统方式：UserService 直接依赖 MySQLUserRepository</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserRepository</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> userRepo </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MySQLUserRepository</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 硬编码</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI 是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter 方法注入和接口注入。</p>`,29)])])}const o=s(e,[["render",l]]),d=JSON.parse('{"path":"/posts/%E5%90%8E%E7%AB%AF/Spring/%E8%AE%A4%E8%AF%86Spring%20ioC%E5%92%8CDI.html","title":"认识Spring ioC和DI","lang":"zh-CN","frontmatter":{"title":"认识Spring ioC和DI","date":"2025-11-29T00:00:00.000Z","tag":["后端"],"categories":["后端"],"cover":null,"article":true,"star":false,"description":"Spring IoC Spring IoC（（Inversion of Control）控制反转）​是 Spring 框架的核心机制（理解为设计模式），用于​​解耦组件依赖关系​​，将对象的创建、依赖管理和生命周期交由 Spring 容器统一控制 可以理解为类与类之间的依赖通过容器来控制、配置实现； 传统编程中，对象自己创建依赖的其他对象（比如A类里直...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"认识Spring ioC和DI\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-11-29T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-02T07:48:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"qiuxz\\",\\"url\\":\\"/\\"}]}"],["meta",{"property":"og:url","content":"https://q1251465796.github.io/posts/%E5%90%8E%E7%AB%AF/Spring/%E8%AE%A4%E8%AF%86Spring%20ioC%E5%92%8CDI.html"}],["meta",{"property":"og:site_name","content":"qiuxz"}],["meta",{"property":"og:title","content":"认识Spring ioC和DI"}],["meta",{"property":"og:description","content":"Spring IoC Spring IoC（（Inversion of Control）控制反转）​是 Spring 框架的核心机制（理解为设计模式），用于​​解耦组件依赖关系​​，将对象的创建、依赖管理和生命周期交由 Spring 容器统一控制 可以理解为类与类之间的依赖通过容器来控制、配置实现； 传统编程中，对象自己创建依赖的其他对象（比如A类里直..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-02T07:48:49.000Z"}],["meta",{"property":"article:tag","content":"后端"}],["meta",{"property":"article:published_time","content":"2025-11-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-02T07:48:49.000Z"}]]},"git":{"createdTime":1764429410000,"updatedTime":1764661729000,"contributors":[{"name":"qiuxz","username":"qiuxz","email":"qiuxzheng0811@163.com","commits":2,"url":"https://github.com/qiuxz"}]},"readingTime":{"minutes":3.49,"words":1046},"filePathRelative":"posts/后端/Spring/认识Spring ioC和DI.md","excerpt":"<h2>Spring IoC</h2>\\n<p><strong>Spring IoC</strong>（（Inversion of Control）控制反转）​是 Spring 框架的核心机制（理解为设计模式），用于​<strong>​解耦组件依赖关系​</strong>​，将对象的创建、依赖管理和生命周期交<strong>由 Spring 容器统一控制</strong></p>\\n<p>可以理解为<strong>类与类之间的依赖通过容器来控制、配置实现</strong>；</p>\\n<p>传统编程中，对象自己创建依赖的其他对象（比如A类里直接new B类）。如果代码中直接写<code>A a = new A();</code>，然后<code>a.setB(new B());</code>，会导致A和B强绑定。修改B的代码时，必须同步修改A的代码，维护成本极高。</p>","autoDesc":true}');export{o as comp,d as data};
